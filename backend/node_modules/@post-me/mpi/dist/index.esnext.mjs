import { WorkerMessenger, ParentHandshake, ChildHandshake, PortMessenger } from 'post-me';

function createUniqueIdFn() {
    let __id = 0;
    return function () {
        const id = __id;
        __id += 1;
        return id;
    };
}
function createPool(workers, ChannelConstructor) {
    ChannelConstructor = ChannelConstructor || MessageChannel;
    return new Promise((resolve, reject) => {
        const size = workers.length;
        // Create channels for direct inter-worker communication
        const channels = {};
        for (let i = 0; i < size; ++i) {
            for (let j = i; j < size; ++j) {
                const key = channelKey(i, j);
                channels[key] = new ChannelConstructor();
            }
        }
        const connectTasks = workers.map((worker, rank) => {
            let messenger = new WorkerMessenger({ worker });
            return ParentHandshake(messenger).then((connection) => {
                return connection;
            });
        });
        Promise.all(connectTasks)
            .then((connections) => {
            const initializeTasks = connections.map((connection, rank) => {
                const remoteHandle = connection.remoteHandle();
                // Ensure MessagePorts to create direct Worker-to-Workern communication are transferred.
                remoteHandle.setCallTransfer('initComm', (_rank, ports) => ports.filter((port) => port !== undefined));
                const ports = [];
                for (let otherRank = 0; otherRank < size; ++otherRank) {
                    if (otherRank === rank) {
                        ports.push(undefined);
                    }
                    else {
                        const key = channelKey(rank, otherRank);
                        const channel = channels[key];
                        let port = rank < otherRank ? channel.port1 : channel.port2;
                        ports.push(port);
                    }
                }
                return remoteHandle.call('initComm', rank, ports);
            });
            Promise.all(initializeTasks)
                .then(() => {
                const workerPool = new ConcreteWorkerPool(connections);
                resolve(workerPool);
            })
                .catch(reject);
        })
            .catch(reject);
    });
}
class ConcreteWorkerPool {
    constructor(connections) {
        this._connections = connections;
        this._taskId = createUniqueIdFn();
    }
    call(methodName, argsFn, transferFn) {
        const taskId = this._taskId();
        return Promise.all(this._connections.map((connection, rank) => {
            const remoteHandle = connection.remoteHandle();
            const args = argsFn(rank);
            const options = transferFn
                ? { transfer: transferFn(rank, args) }
                : undefined;
            return remoteHandle.customCall(methodName, [taskId, ...args], options);
        }));
    }
}
function channelKey(_i, _j) {
    let i = _i;
    let j = _j;
    if (i > j) {
        i = _j;
        j = _i;
    }
    return `${i},${j}`;
}

const BARRIER_TAG = -1;
const BCAST_TAG = -2;
const SCATTER_TAG = -3;
const GATHER_TAG = -4;
const REDUCE_TAG = -5;
const buildBarrier = function (rank, size, send, recv) {
    return async function () {
        const destination = (rank + 1) % size;
        const source = (size + rank - 1) % size;
        const tag = BARRIER_TAG;
        let rounds = 2;
        while (rounds > 0) {
            if (rank === 0) {
                await send(true, destination, tag);
            }
            await recv(source, tag);
            if (rank !== 0) {
                await send(true, destination, tag);
            }
            rounds -= 1;
        }
    };
};
const buildBcast = function (rank, size, send, recv) {
    return async function (data, root) {
        const tag = BCAST_TAG;
        // O(logN) broadcast implementation
        const delta = (rank + size - root) % size;
        let stride = 1;
        while (stride < size) {
            if (delta < stride && delta + stride < size) {
                const destination = (rank + stride) % size;
                send(data, destination, tag);
            }
            else if (delta >= stride && delta - stride < stride) {
                const source = (rank + size - stride) % size;
                data = await recv(source, tag);
            }
            stride = stride * 2;
        }
        return data;
    };
};
const buildScatter = function (rank, size, send, recv) {
    return async function (data, root) {
        const tag = SCATTER_TAG;
        // O(N) scatter implementation can probably do better
        if (rank === root) {
            const fullSize = data.length;
            const subSize = Math.max(Math.floor(fullSize / size), 1);
            const remainder = Math.max(fullSize - subSize * size, 0);
            for (let destination = 0; destination < size; ++destination) {
                const extraStart = destination < remainder ? destination : remainder;
                const extraStop = destination < remainder ? 1 : 0;
                const start = destination * subSize + extraStart;
                const stop = start + subSize + extraStop;
                const subData = data.slice(start, stop);
                let transfer;
                if (subData.buffer) {
                    transfer = [subData.buffer];
                }
                send(subData, destination, tag, transfer);
            }
        }
        const scatterData = await recv(root, tag);
        return scatterData;
    };
};
const buildGather = function (rank, size, send, recv) {
    return async function (data, root) {
        const tag = GATHER_TAG;
        // O(N) scatter implementation can probably do better
        let transfer;
        if (data.buffer) {
            transfer = [data.buffer];
        }
        send(data, root, tag, transfer);
        let gatheredData = null;
        if (rank === root) {
            for (let source = 0; source < size; ++source) {
                let subData = await recv(source, tag);
                if (source === 0) {
                    gatheredData = subData;
                }
                else {
                    const C = gatheredData.constructor;
                    gatheredData = C.of(...gatheredData, ...subData);
                }
            }
        }
        return gatheredData;
    };
};
const buildAllGather = function (rank, size, send, recv) {
    return async function (data) {
        const gather = buildGather(rank, size, send, recv);
        const bcast = buildBcast(rank, size, send, recv);
        const root = 0;
        const gatheredData = await gather(data, root);
        return await bcast(gatheredData, root);
    };
};
const buildReduce = function (rank, size, send, recv) {
    return async function reduce(data, reducer, root) {
        const tag = REDUCE_TAG;
        let result = data;
        // O(logN) reduce implementation
        const delta = (rank + size - root) % size;
        let stride = 1;
        while (stride <= Math.floor(size / 2)) {
            if (delta % stride !== 0) {
                break;
            }
            const currSize = Math.floor(size / stride);
            // If there is an unpaired process at this iteration, reduce with root
            if (currSize % 2 !== 0) {
                const unpaired = (root + (currSize - 1) * stride) % size;
                if (rank === unpaired) {
                    send(result, root, tag);
                    break;
                }
                else if (rank === root) {
                    const otherResult = await recv(unpaired, tag);
                    result = reducer(result, otherResult);
                }
            }
            if (delta % (stride * 2) === 0) {
                const source = (rank + stride) % size;
                const otherResult = await recv(source, tag);
                result = reducer(result, otherResult);
            }
            else {
                const destination = (rank + size - stride) % size;
                send(result, destination, tag);
                break;
            }
            stride = stride * 2;
        }
        if (rank === root) {
            return result;
        }
        else {
            return null;
        }
    };
};
const buildAllReduce = function (rank, size, send, recv) {
    return async function (data, reducer) {
        const reduce = buildReduce(rank, size, send, recv);
        const bcast = buildBcast(rank, size, send, recv);
        const root = 0;
        const reducedData = await reduce(data, reducer, root);
        return await bcast(reducedData, root);
    };
};

function joinPool(workerScope) {
    return new Promise((resolve, reject) => {
        let messenger = new WorkerMessenger({ worker: workerScope });
        ChildHandshake(messenger)
            .then((connection) => {
            const parentConnection = connection;
            const initMethods = {
                initComm(rank, ports) {
                    return new Promise((thisResolve, thisReject) => {
                        const handshakes = ports.map((port, otherRank) => {
                            if (port === undefined) {
                                return Promise.resolve(undefined);
                            }
                            let messenger = new PortMessenger({ port });
                            const Handshake = otherRank < rank ? ChildHandshake : ParentHandshake;
                            return Handshake(messenger);
                        });
                        Promise.all(handshakes)
                            .then((connections) => {
                            const poolConnection = new ConcretePoolConnection(parentConnection, rank, connections);
                            resolve(poolConnection);
                            thisResolve();
                        })
                            .catch((err) => {
                            reject(err);
                            thisReject(err);
                        });
                    });
                },
            };
            parentConnection.localHandle().setMethods(initMethods);
        })
            .catch(reject);
    });
}
class ConcretePoolConnection {
    constructor(parentConnection, rank, connections) {
        this._rank = rank;
        this._size = connections.length;
        this._connections = connections;
        this._parentConnection = parentConnection;
        this._communicators = {};
        this._connections.forEach((connection) => {
            if (connection !== undefined) {
                const localHandle = connection.localHandle();
                localHandle.setMethod('send', this._handleSend.bind(this));
            }
        });
    }
    registerMethods(methods) {
        const exposedMethods = Object.entries(methods).reduce((tot, [methodName, method]) => {
            tot[methodName] = this._exposeParallelMethod(method);
            return tot;
        }, {});
        this._parentConnection.localHandle().setMethods(exposedMethods);
    }
    registerMethod(methodName, method) {
        this._parentConnection
            .localHandle()
            .setMethod(methodName, this._exposeParallelMethod(method));
    }
    setReturnTransfer(methodName, transfer) {
        this._parentConnection
            .localHandle()
            .setReturnTransfer(methodName, transfer);
    }
    _exposeParallelMethod(method) {
        return (taskId, ...args) => {
            const send = (data, destination, tag, transfer) => {
                return this._sendToChannel(taskId, this._rank, destination, tag, data, transfer);
            };
            const communicator = new ConcreteCommunicator(this._rank, this._size, send);
            this._communicators[taskId] = communicator;
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    Promise.resolve(method(communicator)(...args))
                        .then(resolve)
                        .catch(reject);
                }, 0);
            });
        };
    }
    _sendToChannel(taskId, source, destination, tag, data, transfer) {
        const connection = this._connections[destination];
        if (connection === undefined) {
            return Promise.reject(new Error('The destination is out of range'));
        }
        const remoteHandle = connection.remoteHandle();
        return remoteHandle.customCall('send', [taskId, source, tag, data], {
            transfer,
        });
    }
    _handleSend(taskId, source, tag, data) {
        const communicator = this._communicators[taskId];
        if (communicator === undefined) {
            return Promise.reject('A communicator does not exist for this task.');
        }
        return communicator._handleSend(source, tag, data);
    }
}
function messageKey(source, tag) {
    return `${source},${tag}`;
}
class ConcreteCommunicator {
    constructor(rank, size, sendFn) {
        this._rank = rank;
        this._size = size;
        this._messageQueue = {};
        this._receiveQueue = {};
        this._sendFn = sendFn;
        const send = this.send.bind(this);
        const recv = this.recv.bind(this);
        this.bcast = buildBcast(rank, size, send, recv);
        this.barrier = buildBarrier(rank, size, send, recv);
        this.scatter = buildScatter(rank, size, send, recv);
        this.gather = buildGather(rank, size, send, recv);
        this.allGather = buildAllGather(rank, size, send, recv);
        this.reduce = buildReduce(rank, size, send, recv);
        this.allReduce = buildAllReduce(rank, size, send, recv);
    }
    rank() {
        return this._rank;
    }
    size() {
        return this._size;
    }
    send(data, destination, tag, transfer) {
        if (destination === this.rank()) {
            this._handleSend(this.rank(), tag, data);
            // Resolve to avoid deadlock
            return Promise.resolve();
        }
        return this._sendFn(data, destination, tag, transfer);
    }
    recv(source, tag) {
        return new Promise((resolve, reject) => {
            const key = messageKey(source, tag);
            if (this._messageQueue[key] && this._messageQueue[key].length > 0) {
                const [sender] = this._messageQueue[key].splice(0, 1);
                sender.resolve();
                resolve(sender.data);
            }
            else {
                if (this._receiveQueue[key] === undefined) {
                    this._receiveQueue[key] = [];
                }
                this._receiveQueue[key].push({ resolve, reject });
            }
        });
    }
    _handleSend(source, tag, data) {
        return new Promise((resolve, reject) => {
            const key = messageKey(source, tag);
            if (this._receiveQueue[key] && this._receiveQueue[key].length > 0) {
                const [receiver] = this._receiveQueue[key].splice(0, 1);
                resolve();
                receiver.resolve(data);
            }
            else {
                if (this._messageQueue[key] === undefined) {
                    this._messageQueue[key] = [];
                }
                this._messageQueue[key].push({ resolve, reject, data });
            }
        });
    }
}

export { createPool, joinPool };
