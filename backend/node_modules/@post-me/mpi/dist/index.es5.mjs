import { WorkerMessenger, ParentHandshake, ChildHandshake, PortMessenger } from 'post-me';

function createUniqueIdFn() {
  let __id = 0;
  return function () {
    const id = __id;
    __id += 1;
    return id;
  };
}

function createPool(workers, ChannelConstructor) {
  ChannelConstructor = ChannelConstructor || MessageChannel;
  return new Promise((resolve, reject) => {
    const size = workers.length; // Create channels for direct inter-worker communication

    const channels = {};

    for (let i = 0; i < size; ++i) {
      for (let j = i; j < size; ++j) {
        const key = channelKey(i, j);
        channels[key] = new ChannelConstructor();
      }
    }

    const connectTasks = workers.map((worker, rank) => {
      let messenger = new WorkerMessenger({
        worker
      });
      return ParentHandshake(messenger).then(connection => {
        return connection;
      });
    });
    Promise.all(connectTasks).then(connections => {
      const initializeTasks = connections.map((connection, rank) => {
        const remoteHandle = connection.remoteHandle(); // Ensure MessagePorts to create direct Worker-to-Workern communication are transferred.

        remoteHandle.setCallTransfer('initComm', (_rank, ports) => ports.filter(port => port !== undefined));
        const ports = [];

        for (let otherRank = 0; otherRank < size; ++otherRank) {
          if (otherRank === rank) {
            ports.push(undefined);
          } else {
            const key = channelKey(rank, otherRank);
            const channel = channels[key];
            let port = rank < otherRank ? channel.port1 : channel.port2;
            ports.push(port);
          }
        }

        return remoteHandle.call('initComm', rank, ports);
      });
      Promise.all(initializeTasks).then(() => {
        const workerPool = new ConcreteWorkerPool(connections);
        resolve(workerPool);
      }).catch(reject);
    }).catch(reject);
  });
}

class ConcreteWorkerPool {
  constructor(connections) {
    this._connections = connections;
    this._taskId = createUniqueIdFn();
  }

  call(methodName, argsFn, transferFn) {
    const taskId = this._taskId();

    return Promise.all(this._connections.map((connection, rank) => {
      const remoteHandle = connection.remoteHandle();
      const args = argsFn(rank);
      const options = transferFn ? {
        transfer: transferFn(rank, args)
      } : undefined;
      return remoteHandle.customCall(methodName, [taskId, ...args], options);
    }));
  }

}

function channelKey(_i, _j) {
  let i = _i;
  let j = _j;

  if (i > j) {
    i = _j;
    j = _i;
  }

  return "".concat(i, ",").concat(j);
}

const BARRIER_TAG = -1;
const BCAST_TAG = -2;
const SCATTER_TAG = -3;
const GATHER_TAG = -4;
const REDUCE_TAG = -5;

const buildBarrier = function (rank, size, send, recv) {
  return async function () {
    const destination = (rank + 1) % size;
    const source = (size + rank - 1) % size;
    const tag = BARRIER_TAG;
    let rounds = 2;

    while (rounds > 0) {
      if (rank === 0) {
        await send(true, destination, tag);
      }

      await recv(source, tag);

      if (rank !== 0) {
        await send(true, destination, tag);
      }

      rounds -= 1;
    }
  };
};

const buildBcast = function (rank, size, send, recv) {
  return async function (data, root) {
    const tag = BCAST_TAG; // O(logN) broadcast implementation

    const delta = (rank + size - root) % size;
    let stride = 1;

    while (stride < size) {
      if (delta < stride && delta + stride < size) {
        const destination = (rank + stride) % size;
        send(data, destination, tag);
      } else if (delta >= stride && delta - stride < stride) {
        const source = (rank + size - stride) % size;
        data = await recv(source, tag);
      }

      stride = stride * 2;
    }

    return data;
  };
};

const buildScatter = function (rank, size, send, recv) {
  return async function (data, root) {
    const tag = SCATTER_TAG; // O(N) scatter implementation can probably do better

    if (rank === root) {
      const fullSize = data.length;
      const subSize = Math.max(Math.floor(fullSize / size), 1);
      const remainder = Math.max(fullSize - subSize * size, 0);

      for (let destination = 0; destination < size; ++destination) {
        const extraStart = destination < remainder ? destination : remainder;
        const extraStop = destination < remainder ? 1 : 0;
        const start = destination * subSize + extraStart;
        const stop = start + subSize + extraStop;
        const subData = data.slice(start, stop);
        let transfer;

        if (subData.buffer) {
          transfer = [subData.buffer];
        }

        send(subData, destination, tag, transfer);
      }
    }

    const scatterData = await recv(root, tag);
    return scatterData;
  };
};

const buildGather = function (rank, size, send, recv) {
  return async function (data, root) {
    const tag = GATHER_TAG; // O(N) scatter implementation can probably do better

    let transfer;

    if (data.buffer) {
      transfer = [data.buffer];
    }

    send(data, root, tag, transfer);
    let gatheredData = null;

    if (rank === root) {
      for (let source = 0; source < size; ++source) {
        let subData = await recv(source, tag);

        if (source === 0) {
          gatheredData = subData;
        } else {
          const C = gatheredData.constructor;
          gatheredData = C.of(...gatheredData, ...subData);
        }
      }
    }

    return gatheredData;
  };
};

const buildAllGather = function (rank, size, send, recv) {
  return async function (data) {
    const gather = buildGather(rank, size, send, recv);
    const bcast = buildBcast(rank, size, send, recv);
    const root = 0;
    const gatheredData = await gather(data, root);
    return await bcast(gatheredData, root);
  };
};

const buildReduce = function (rank, size, send, recv) {
  return async function reduce(data, reducer, root) {
    const tag = REDUCE_TAG;
    let result = data; // O(logN) reduce implementation

    const delta = (rank + size - root) % size;
    let stride = 1;

    while (stride <= Math.floor(size / 2)) {
      if (delta % stride !== 0) {
        break;
      }

      const currSize = Math.floor(size / stride); // If there is an unpaired process at this iteration, reduce with root

      if (currSize % 2 !== 0) {
        const unpaired = (root + (currSize - 1) * stride) % size;

        if (rank === unpaired) {
          send(result, root, tag);
          break;
        } else if (rank === root) {
          const otherResult = await recv(unpaired, tag);
          result = reducer(result, otherResult);
        }
      }

      if (delta % (stride * 2) === 0) {
        const source = (rank + stride) % size;
        const otherResult = await recv(source, tag);
        result = reducer(result, otherResult);
      } else {
        const destination = (rank + size - stride) % size;
        send(result, destination, tag);
        break;
      }

      stride = stride * 2;
    }

    if (rank === root) {
      return result;
    } else {
      return null;
    }
  };
};

const buildAllReduce = function (rank, size, send, recv) {
  return async function (data, reducer) {
    const reduce = buildReduce(rank, size, send, recv);
    const bcast = buildBcast(rank, size, send, recv);
    const root = 0;
    const reducedData = await reduce(data, reducer, root);
    return await bcast(reducedData, root);
  };
};

function joinPool(workerScope) {
  return new Promise((resolve, reject) => {
    let messenger = new WorkerMessenger({
      worker: workerScope
    });
    ChildHandshake(messenger).then(connection => {
      const parentConnection = connection;
      const initMethods = {
        initComm(rank, ports) {
          return new Promise((thisResolve, thisReject) => {
            const handshakes = ports.map((port, otherRank) => {
              if (port === undefined) {
                return Promise.resolve(undefined);
              }

              let messenger = new PortMessenger({
                port
              });
              const Handshake = otherRank < rank ? ChildHandshake : ParentHandshake;
              return Handshake(messenger);
            });
            Promise.all(handshakes).then(connections => {
              const poolConnection = new ConcretePoolConnection(parentConnection, rank, connections);
              resolve(poolConnection);
              thisResolve();
            }).catch(err => {
              reject(err);
              thisReject(err);
            });
          });
        }

      };
      parentConnection.localHandle().setMethods(initMethods);
    }).catch(reject);
  });
}

class ConcretePoolConnection {
  constructor(parentConnection, rank, connections) {
    this._rank = rank;
    this._size = connections.length;
    this._connections = connections;
    this._parentConnection = parentConnection;
    this._communicators = {};

    this._connections.forEach(connection => {
      if (connection !== undefined) {
        const localHandle = connection.localHandle();
        localHandle.setMethod('send', this._handleSend.bind(this));
      }
    });
  }

  registerMethods(methods) {
    const exposedMethods = Object.entries(methods).reduce((tot, [methodName, method]) => {
      tot[methodName] = this._exposeParallelMethod(method);
      return tot;
    }, {});

    this._parentConnection.localHandle().setMethods(exposedMethods);
  }

  registerMethod(methodName, method) {
    this._parentConnection.localHandle().setMethod(methodName, this._exposeParallelMethod(method));
  }

  setReturnTransfer(methodName, transfer) {
    this._parentConnection.localHandle().setReturnTransfer(methodName, transfer);
  }

  _exposeParallelMethod(method) {
    return (taskId, ...args) => {
      const send = (data, destination, tag, transfer) => {
        return this._sendToChannel(taskId, this._rank, destination, tag, data, transfer);
      };

      const communicator = new ConcreteCommunicator(this._rank, this._size, send);
      this._communicators[taskId] = communicator;
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          Promise.resolve(method(communicator)(...args)).then(resolve).catch(reject);
        }, 0);
      });
    };
  }

  _sendToChannel(taskId, source, destination, tag, data, transfer) {
    const connection = this._connections[destination];

    if (connection === undefined) {
      return Promise.reject(new Error('The destination is out of range'));
    }

    const remoteHandle = connection.remoteHandle();
    return remoteHandle.customCall('send', [taskId, source, tag, data], {
      transfer
    });
  }

  _handleSend(taskId, source, tag, data) {
    const communicator = this._communicators[taskId];

    if (communicator === undefined) {
      return Promise.reject('A communicator does not exist for this task.');
    }

    return communicator._handleSend(source, tag, data);
  }

}

function messageKey(source, tag) {
  return "".concat(source, ",").concat(tag);
}

class ConcreteCommunicator {
  constructor(rank, size, sendFn) {
    this._rank = rank;
    this._size = size;
    this._messageQueue = {};
    this._receiveQueue = {};
    this._sendFn = sendFn;
    const send = this.send.bind(this);
    const recv = this.recv.bind(this);
    this.bcast = buildBcast(rank, size, send, recv);
    this.barrier = buildBarrier(rank, size, send, recv);
    this.scatter = buildScatter(rank, size, send, recv);
    this.gather = buildGather(rank, size, send, recv);
    this.allGather = buildAllGather(rank, size, send, recv);
    this.reduce = buildReduce(rank, size, send, recv);
    this.allReduce = buildAllReduce(rank, size, send, recv);
  }

  rank() {
    return this._rank;
  }

  size() {
    return this._size;
  }

  send(data, destination, tag, transfer) {
    if (destination === this.rank()) {
      this._handleSend(this.rank(), tag, data); // Resolve to avoid deadlock


      return Promise.resolve();
    }

    return this._sendFn(data, destination, tag, transfer);
  }

  recv(source, tag) {
    return new Promise((resolve, reject) => {
      const key = messageKey(source, tag);

      if (this._messageQueue[key] && this._messageQueue[key].length > 0) {
        const [sender] = this._messageQueue[key].splice(0, 1);

        sender.resolve();
        resolve(sender.data);
      } else {
        if (this._receiveQueue[key] === undefined) {
          this._receiveQueue[key] = [];
        }

        this._receiveQueue[key].push({
          resolve,
          reject
        });
      }
    });
  }

  _handleSend(source, tag, data) {
    return new Promise((resolve, reject) => {
      const key = messageKey(source, tag);

      if (this._receiveQueue[key] && this._receiveQueue[key].length > 0) {
        const [receiver] = this._receiveQueue[key].splice(0, 1);

        resolve();
        receiver.resolve(data);
      } else {
        if (this._messageQueue[key] === undefined) {
          this._messageQueue[key] = [];
        }

        this._messageQueue[key].push({
          resolve,
          reject,
          data
        });
      }
    });
  }

}

export { createPool, joinPool };
